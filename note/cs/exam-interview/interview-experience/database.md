## Mysql基础

数据库不仅作为一个`存储数据`的容器，而且我还要按照自己的需要能够方便的`拿数据`，那么这些数据该如何存放在这个容器中呢？

选择一：数据之间没有任何规律，就乱放。

缺点：

- `拿数据`的时候，只能一条一条去检查是否为自己想要的数据，时间复杂度就是`O(N)`。

- `存数据`的话，我也不知道存储的方式是什么，时间复杂度不能计算。

选择二：所有的数据按照某种规则进行`高效的存储`，使之能够`高效地`实现`按需拿数据`，而且还要能高效地`删除`和`修改`。

```
从对数据进行增删改查的时间复杂度方面进行考虑。
	1.从历史来讲，对数据的处理主要是读(查)多写(增，删，改)少的背景。
	2.关系型数据库按照行格式来存储数据。
	3.存储的数据量达到千万级别。
	4.采用性价比高的存储材料。
```



## 事务

> 逻辑上的一组操作，要么全部执行，要么全部不执行。

例如：`A`向`B`转账100RMB。

这个过程至少包含两个步骤：

1. `A账户`减少100RMB。
2. `B账户`增加100RMB。

事务就是要么两个步骤都发生，要么都不发生。



### 数据库事务

定义：满足ACID的一组(或一个)数据库操作。





### 并发事务出现的问题

问题：事务的执行不是有隔离性吗？为什么还会出现并发事务的问题？

答：因为多个事务想要写同一个数据的时候，根据事务隔离性的性质，其它事务应该排队，即等前面的事务执行完以后，再执行，但是这样的话会影响性能，因此舍弃一部分隔离性，来提升性能。

多个事务并发执行，写同一个数据的时候就会出现以下问题：























## 索引

### 0.索引的数据结构为什么选择二叉树呢？

```
我:
设计者为什么要在数据库中加入索引？
数据库是为了存放数据的，既然是存放数据，肯定也是为了方便以后拿数据，肯定不能乱放，

索引实现的功能：高效地实现增删改查，排序，范围查询。
考虑数据结构完成这些功能的性能如何。

不仅要从理论上考虑时间复杂度，还要物理I/O上考虑。————即索引会存储在磁盘上面。
```

根据平均的读写复杂度[^1]分析，`O(1)`<`O(logN)`<`O(N)`。

| 平均读写复杂度 | 数据结构   | 特点                             |
| -------------- | ---------- | -------------------------------- |
| O(1)           | 哈希表     | 对`范围查询`和`排序操作`不友好。 |
| O(log N)       | 二叉搜索树 | 天然支持范围查找和排序。         |
|                |            |                                  |

读写时间复杂度为`O(1)`的数据结构：哈希表。但是当数据量比较大的时候，即哈希冲突发生的次数较多的情况下，哈希表的读写时间复杂度就会不稳定。但是再怎么不稳定，如果不会超过`logn`不还是一种优秀的数据结构吗？扩容操作的时间复杂度就是`O（N）`，但是`范围查询`和`排序`的时间复杂度呢？范围查询只能遍历整个哈希表，时间复杂度就是`O（N）`，排序操作也是要先遍历哈希表，然后在内存中对这些记录进行排序，时间复杂度肯定`大于等于O（N）`。

因此我们不考虑哈希表，然后再考虑时间复杂度为`O(logN)`的数据结构，二叉树搜索树，平衡二叉树，红黑树，b树，b+树天然就支持`范围查询`和`排序`，那么我们应该选择哪种数据结构呢？那我们还是比较他们的对数据进行`增删改查`，`范围查找`和`排序`的`时间复杂度`不就OK了吗？

```
问题：tm的掌握这些数据结构挺花时间的。但是你现在的时间不够了啊。
```

`Mysql`中`InnoDB`支持的索引有`哈希索引`和`B+树索引`。 

`哈希索引`中查询某条记录速度很快，但是不能进行`范围查找`。

`B+树索引`的叶子节点就是所有的记录，而且这些记录是通过`链表`的形式连接起来的，就方便进行`范围查询`。

实现的功能：

- 范围查找
- 排序

[参考链接1]: https://cloud.tencent.com/developer/article/1831560
[参考链接2]: https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html

[参考链接3]: https://zhuanlan.zhihu.com/p/273829162



### 1.哈希索引和B+树索引的区别

- 哈希索引不支持`范围查询`。
- 哈希索引存在哈希冲突，因此哈希索引`不稳定`，B+树索引的查询效率`稳定`。
- 由于哈希表是无序的，因此哈希索引不支持排序。
- 哈希表不支持模糊查询



### 2.为什么平衡二叉树不适合实现数据库索引

> 对数据进行增删改查的效率，以及平衡二叉树的特征来考虑。

平衡二叉树一个节点只有一条数据，因此，若索引中的数据量很大的时候，平衡二叉树的深度也会很大，虽然从理论上讲平衡二叉树的查找时间复杂度是
$$
\log_2N
$$
平衡二叉树的只是`逻辑上`的结构，但是实际的`物理存储结构`，要么是数组，要么是链表。在磁盘上用`链表`实现，那总是要读磁盘的话，时间复杂度会很高，因为每一次读磁盘的话，又不会只是读一个记录所占的那块空间，而是按照页的大小来读。那相对于数组来讲的话，时间复杂度会更高。因此，采用数组来存储平衡二叉树。

由于索引文件在较大的情况下，索引文件不能一次性读入内存，因此只能读取某些页，而且由于平衡二叉树在逻辑上相邻的记录但是在磁盘上却离得很远，因此每次读的页中很多数据根本不需要，需要`多次读取磁盘`，需要的时间较多。因此平衡二叉树还是不适合作为索引的数据结构。

[参考文档]: https://blog.csdn.net/weixin_30531261/article/details/79312676





### 3.为什么B+树比B树更适合实现数据库索引

> 从使用索引，以及B树和B+树的结构特征的角度来看。

B树与B+树的差别

B树的每个数据页中都会有存储完整的记录，但是B+树只有叶子节点才会存储完整的记录，其它节点只是存储主键值以及其它数据页的位置。

B+树

![](https://cdn.jsdelivr.net/gh/1907-peng/pictures/img/Directory_Of_DirectoryRecords.png)

- B+树的数据全部都在叶子节点，而且叶子节点又通过链表的形式连接起来，而B树在所有的节点中都有数据（跨节点意味着数据页在磁盘上的分布会很分散，在磁盘读写时需要额外的`寻道`和`旋转等待`的时间），因此，B+树更在进行`范围查询`的时候，效率更高。B树就是因为范围查询的时候，例如查询主键从4-100的记录，需要在页10，页30，页28，页29之间进行切换，就会导致在磁盘上的时间开销就会比较大。



### 4.索引的类型以及索引的作用

从`存储引擎`的层面来回答的话：

- B+树索引

- 哈希索引

   将某个或者某几个字段的值作为hash函数的输入值，然后计算得到哈希值，保存哈希值，以及指向该条记录的指针。

   ![hash_index](https://cdn.jsdelivr.net/gh/1907-peng/pictures/img/hash_index.png)

   `bukets`：由`key值计算得到的哈希值`以及`指向数据行的物理位置的指针`组成的哈希表。

   [数据结构-哈希表]: D:\天翼云盘同步盘\Markdown笔记\学习笔记\计算机\数据结构\常见数据结构.md

   自适应哈希索引：在`InnoDB `中，若某个二级索引经常被使用，则创建该二级索引对应的哈希索引。

- 全文索引

   原理：`倒排索引`。 输入关键词，找到与该关键词有关的文章。例如：搜索引擎，我们输入一些关键词，就能找到包含有这些关键词的网站。

   在表的某个字段建立全文索引过程，例如该字段的值是一篇一篇的文章

   1. 利用分词器对文章中的单词进行提取，作为辅助表的列，辅助表记录了索引出现的文章ID号——inverted file index（或者文章ID号，在文章的哪一行——full inverted index）

      ![auxiliary_table](https://cdn.jsdelivr.net/gh/1907-peng/pictures/img/auxiliary_table.png)

      [参考链接]: http://bridgeforyou.cn/2019/07/23/Inverted-Index/

      

- 空间数据索引（待学习）

   `MyISAM`支持

> 索引是在存储引擎层实现的，从`存储引擎`的层面回答，更加普遍的答案。

`聚簇索引`和`二级索引`。——这是在`innodb`中的`B+`树索引。

聚簇索引的作用：

- 加快查询速度

   如果没有索引，那么我们查询数据的时候，只能通过遍历的方式来找到我们需要的数据，这样的时间复杂度会达到`O(N)`，但是我们使用索引的话，能使查询的时间复杂度达到`O(logN)`。

二级索引的作用：

- 排序

   例如，已经根据`person_info`表的`name,birthday,phone_number`三个字段建立了联合索引`idx_name_birthday_phone_number`，现在我们需要从`person_info`中拿到所有记录，并且根据`name`,`birthday`,`phone_number`对结果进行排序。

   ```sql
   SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
   ```

   因此，我们可以直接从`idx_name_birthday_phone_number`索引中拿到记录的主键值，然后进行回表操作，所以我们说索引具有排序的功能。
   
- 全值匹配

- 匹配左边的列

- 匹配列前缀

- 匹配范围值

- 精确匹配某一列并范围匹配另外一列

- 分组

### 5.什么情况需要建二级索引，什么情况不需要建索引

这里是指二级索引，聚簇索引是默认创建的。

那就根据二级索引的作用来答。

需要建二级索引的情况：

- 为出现在`where`,`order by`, `group by`子句中的列创建索引。
- 加快表连接的速度（待学习）



不需要建二级索引的情况：

- 表中记录比较少
- 列的基数比较小
- 经常需要增，删，改的表

### 6.索引的数据结构

从存储引擎的层面来考虑（说常用的索引类型的数据结构），有B+树索引，哈希索引，全文索引，空间数据索引。



### 7.索引的分类

根据`底层数据结构`来划分：主要就是`B+树索引`和`哈希索引`。还有全文索引，空间数据索引。

根据`字段个数`来划分：单值索引，联合索引。

根据是否在`主键`上建立索引来划分：主键索引——叶子节点存储了完整的数据行，辅助索引（二级索引）。

根据`索引结构和数据`是否存放在一起来划分：聚簇索引（主键索引）和非聚簇索引（二级索引）。

#### 非聚簇索引一定要进行回表操作吗？

不是，假如在某个表有`name`字段，且在该字段上建立了索引，那么有以下`sql`语句：

```sql
 SELECT name FROM table WHERE name='guang19';
```

在拿到`name`之后就不需要进行回表操作了。

### 8.什么是最左匹配原则

在表中建立了联合索引`name_birthday_phone_number`，若在查询的时候要想使用到这个联合索引，就必须满足最左匹配原则，即`where`后面出现字段顺序必须是按照联合索引的字段顺序，即`where`先出现`name`,再出现`birthday`，再出现`phone_number`，不能是先出现`birthday`,再`phone_number`。



### 9.关于聚簇索引

若表中没有指定主键，那么`InnoDB`会把表中出现的第一个唯一索引的字段作为主键，若也没有唯一索引，InnoDB就会创建一个`6字节`大小的`自增主键`。



### 10.什么是覆盖索引

`SELECT`子句后面出现的字段，正好出现在这个索引中且查询语句符合最左匹配原则，即不需要进行进行回表操作，就能拿到自己想要的数据，那么这个索引就被称为覆盖索引。



### 11.索引的设计原则

索引就是为了提升查询的速度，怎么设计索引才能增加sql语句的效率呢？

- 为`列的基数`大的列创建索引。

- 为需要进行`查询`，`分组`，`排序`的列建立索引。

- 索引列的`类型`尽量小。

- 只对字符串值的前缀建立索引。

   存在的问题：

   1. 若对完整的字符串建立索引，字符串越长，那么索引所占的物理空间越大。
   2. 对索引列进行字符串比较时，字符串越长，比较时间就越长。——这里的话不应该根据需求来决定吗

### 12.索引什么时候失效

这里要看是什么类型的索引吧。

索引的诞生是为了解决什么问题？

而且这个操作要能使用索引，肯定是使用索引能够让该操作的速度加快，若该操作使用索引反而会变慢，那么索引肯定就会失效了。

如果是B+树索引：

- 不遵循最左匹配原则，则联合索引失效。

- 以`%`开头的`like`查询，例如：`%ab`

- 对索引列进行运算

   ```sql
   SELECT * FROM user WHERE age = age + 1
   ```

- 对索引列使用不等于

如果是哈希索引：

- 进行范围查询
- 进行排序
- 进行模糊查询

### 13.什么是前缀索引

对某些为`字符串型`且`字符串的长度很长`的字段建立索引时，我们只取该字段中的前面部分长度的字符串来建立索引。

优点：（与存储整个字符串相比——需要比较每一个字符，只需进行一次或者几次回表操作——这些回表操作找到的记录都是符合条件的记录）

- 索引所占的空间更小。

- 查询速度更快（它的前提条件是什么，该部分长度的字符串的区分度较高。即如果（理想条件下）该索引中的值`每一条记录都不一样`，那么跟比较整个完整长度的字符串相比，时间大大减少，就能更快地确定主键索引中的主键。若存在重复的记录，还需要回表，找到完整记录，并进行完整字段的比较，直到找到主键索引中符合条件的所有记录；假如这部分的字符串重复率很高，当我们查询的时候，发现有很多记录都符合，那么我们就要去主键索引找到找到对应的记录进行比较（回表）。

   ```sql
   // 创建一个测试表
   CREATE TABLE `x_test` (
     `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
     `x_name` varchar(255) NOT NULL,
     `x_time` int(10) NOT NULL,
     PRIMARY KEY (`id`)
   ) ENGINE=InnoDB AUTO_INCREMENT=4145025 DEFAULT CHARSET=utf8mb4
   
   // 添加200万条测试数据
   INSERT INTO x_test(x_name,x_time) SELECT CONCAT(rand()*3300102,x_name),x_time FROM x_test WHERE id < 30000;
   ```

   - 无索引

      ```sql
      SELECT * FROM x_test WHERE x_name = '1892008.205824857823401.800099203178258.8904820949682635656.62526521254';
      ```

      这种情况下，只能通过`遍历主键索引`来找到满足条件的记录。

      查询时间：2.253s

   - 添加前缀索引（以第一位字符来创建索引）

      ```sql
      alter table x_test add index(x_name(1))
      ```

      第一个字符由于是0-9任意一个，200万条数据在理论上，有20万条记录的第一个字符是相同的，因此，当我们使用前缀索引的时候，在找到大约20万条值为`1`的记录后，找到主键，再根据主键再去主键索引找到对应的用户记录，进行完整字段的比较，这其中肯定有大量的`x_name`不等于`1892008.205824857823401.800099203178258.8904820949682635656.62526521254`的记录，于是就出现了很大的计算浪费。

      ```sql
      SELECT * FROM x_test WHERE x_name = '1892008.205824857823401.800099203178258.8904820949682635656.62526521254';
      ```

      查询时间：3.291s

   - 添加前缀索引（以前面4个字符创建索引）

      ```sql
      alter table x_test add index(x_name(4));
      ```

      `4个字符`出现相同的概率是`1/10000`，200万条记录理论上有`200`条相同的记录。

      查询时间：0.703s

   - 添加前缀索引（以前面7个字符创建索引）

      7个字符出现相同的概率是`千万分之一`

      查询时间：0.014s



[^1]: 平均读写复杂度是怎么算的